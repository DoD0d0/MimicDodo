import os
import wandb
from rsl_rl.env import VecEnv
from rsl_rl.runners.on_policy_runner import OnPolicyRunner
from isaaclab_rl.rsl_rl import export_policy_as_onnx
from whole_body_tracking.utils.exporter import attach_onnx_metadata, export_motion_policy_as_onnx


class MyOnPolicyRunner(OnPolicyRunner):
    def save(self, path: str, infos=None):
        """Save the model and training information."""
        super().save(path, infos)
        if self.logger_type in ["wandb"]:
            # Onnx Export Logik
            policy_path = path.split("model")[0]
            # Sicherstellen, dass der Pfad existiert
            if not os.path.exists(policy_path):
                return
                
            filename = policy_path.split("/")[-2] + ".onnx"
            try:
                export_policy_as_onnx(self.alg.policy, normalizer=self.obs_normalizer, path=policy_path, filename=filename)
                attach_onnx_metadata(self.env.unwrapped, wandb.run.name, path=policy_path, filename=filename)
                wandb.save(policy_path + filename, base_path=os.path.dirname(policy_path))
            except Exception as e:
                print(f"[WARN] ONNX export failed: {e}")


class MotionOnPolicyRunner(OnPolicyRunner):
    def __init__(
        self, env: VecEnv, train_cfg: dict, log_dir: str | None = None, device="cpu", registry_name: str = None
    ):
        super().__init__(env, train_cfg, log_dir, device)
        self.registry_name = registry_name

    def save(self, path: str, infos=None):
        """Save the model and training information."""
        super().save(path, infos)
        
        if self.logger_type in ["wandb"] and wandb.run is not None:
            policy_path = path.split("model")[0]
            # Sicherstellen, dass der Pfad sauber ist (manchmal fehlt der Ordner)
            if not os.path.exists(policy_path):
                return

            filename = policy_path.split("/")[-2] + ".onnx"
            
            # 1. ONNX Export
            try:
                export_motion_policy_as_onnx(
                    self.env.unwrapped, self.alg.policy, normalizer=self.obs_normalizer, path=policy_path, filename=filename
                )
                attach_onnx_metadata(self.env.unwrapped, wandb.run.name, path=policy_path, filename=filename)
                wandb.save(policy_path + filename, base_path=os.path.dirname(policy_path))
            except Exception as e:
                print(f"[WARN] ONNX export failed: {e}")

            # 2. Artifact Link (HIER WAR DER FEHLER)
            if self.registry_name is not None:
                # FIX: Wir prüfen, ob es ein echter Cloud-Name ist (muss ':' enthalten)
                # und filtern unsere Dummy-Namen wie "local_training" raus.
                if ":" in self.registry_name and "local" not in self.registry_name.lower():
                    try:
                        wandb.run.use_artifact(self.registry_name)
                    except Exception as e:
                        print(f"[WARN] Could not log artifact usage to WandB: {e}")
                
                # Namen löschen, damit wir es nicht jedes Mal versuchen
                self.registry_name = None